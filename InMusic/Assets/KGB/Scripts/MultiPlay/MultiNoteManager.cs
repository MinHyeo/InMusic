using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class MultiNoteManager : MonoBehaviour
{
    public ObjectPool measureLinePool; // 경계선 풀
    public ObjectPool notePool1;       // 노트 풀 (1번 키, 4번 키)
    public ObjectPool notePool2;       // 노트 풀 (2번 키, 3번 키)

    public GameObject measureLinePrefab;
    public GameObject notePrefab1;
    public GameObject notePrefab2;
    public Transform spawnArea;
    public Transform judgeLinePos;

    [SerializeField] GameObject songStartNote;

    public int lineCount = 5;          // 초기 경계선 개수
    public float baseScrollSpeed = 1f; // 기본 스크롤 속도
    //public float bpm = 120;            // BPM (비트 당 박자 수)
    public float beatsPerMeasure = 4;  // 마디당 박자 수 (4/4 박자 기준)
    public float noteOffset = 0.15f;   // 노트 시작 오프셋
    public float secondsPerBeat;      // 1비트에 걸리는 시간(초)
    public float measureDuration;     // 한 마디의 지속 시간(초)
    public float lineInterval;        // 마디 간의 간격
    public bool isMoving = false;   //노트 움직임 상태

    private float startPositionY = -1.38f; //노트 이미지에 따른 세부 위치 조절

    public int totalNotes; // 총 노트 개수

    private Dictionary<int, Note_Multi> notesByIndex = new Dictionary<int, Note_Multi>();

    // noteId 기준 판정 저장소
    private Dictionary<int, JudgementData> judgementDict = new Dictionary<int, JudgementData>();
    private Dictionary<int, ScoreData> scoreDataDict = new Dictionary<int, ScoreData>();
    private Queue<ScoreData> scoreDataQueue = new Queue<ScoreData>();
    public static MultiNoteManager Instance { get; private set; }



    void Awake()
    {
        // 싱글톤 인스턴스 설정
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }
    void Start()
    {
    }

    // Update is called once per frame
    void FixedUpdate()
    {
    }

    public void SetNote(BMSData bms)
    {
        isMoving = false;
        baseScrollSpeed = 5f;

        if (bms != null)
        {
            int lastMeasure = bms.notes.Last().measure;
            lineCount = lastMeasure + 5; //전체 마디 수
            secondsPerBeat = 60f / bms.header.bpm; //bpm
            measureDuration = secondsPerBeat * beatsPerMeasure;
            lineInterval = baseScrollSpeed * measureDuration;
            SpawnNotes(bms, spawnArea);
            SpawnMeasureLines();
        }
    }

    void SpawnMeasureLines()
    {
        for (int i = 0; i < lineCount; i++)
        {

            Vector3 spawnPosition = new Vector3(spawnArea.position.x, i * lineInterval - noteOffset + startPositionY + spawnArea.position.y, 0);

            GameObject measureLine = measureLinePool.GetObject();
            measureLine.transform.position = spawnPosition;
            measureLine.GetComponent<ScrollDown_Multi>().SetScrollSpeed(baseScrollSpeed);
            measureLine.SetActive(true);
            ////// 경계선 생성
            //GameObject measureLine = Instantiate(measureLinePrefab, spawnPosition, Quaternion.identity, spawnArea);

            //// 로컬 위치 설정 (필요할 경우)
            //measureLine.transform.localPosition = new Vector3(0, i * lineinterval- noteOffset, 0);
        }
    }

    public void SpawnNotes(BMSData bmsData, Transform spawnArea)
    {
        totalNotes = 0; // 총 노트 개수 초기화
        notesByIndex.Clear(); // 기존에 있던 노트 정보 초기화
        foreach (var noteData in bmsData.notes)
        {
            string data = noteData.noteString;
            int divisions = data.Length / 2; // 마디를 몇 등분할지 계산 (2자리씩 노트)

            for (int i = 0; i < divisions; i++)
            {
                string noteID = data.Substring(i * 2, 2);

                if (noteID != "00") // 노트가 있는 경우만 처리
                {

                    float beatPosition = (float)i / divisions;
                    float yPosition = noteData.measure * lineInterval + +(lineInterval / divisions) * i + startPositionY + spawnArea.position.y;

                    float xPosition = GetChannelPosition(noteData.channel);
                    if (noteID == "02")
                    {
                        // "02"일 때 프리팹 생성 //노래를 시작시키는 투명노트
                        //GameObject specialNote = Instantiate(songStartNote, new Vector3(xPosition, yPosition - 1f, 0), Quaternion.identity, spawnArea);
                        //specialNote.GetComponent<ScrollDown_Multi>().SetScrollSpeed(baseScrollSpeed);
                        //specialNote.SetActive(true);
                    }
                    else
                    {
                        totalNotes++; // 유효한 노트 수 증가
                        GameObject selectedNote = SelectNotePool(noteData.channel).GetObject();
                        selectedNote.GetComponent<ScrollDown_Multi>().SetScrollSpeed(baseScrollSpeed);
                        selectedNote.transform.position = new Vector3(xPosition, yPosition, 0);
                        selectedNote.SetActive(true);

                        Note_Multi noteComp = selectedNote.GetComponent<Note_Multi>();
                        if (noteComp != null)
                        {
                            noteComp.noteIndex = totalNotes; // 1부터 시작하는 인덱스 할당 //판정을 보내기 위해 해당 노트의 인덱스를 알기 위해 씀
                            notesByIndex.Add(totalNotes, noteComp); //딕셔너리에 추가 //판정을 받아서 노트를 찾을 때만 씀
                        }
                    }
                }
            }
        }
        Debug.Log($"Total Notes: {totalNotes}");
    }

    private float GetChannelPosition(int channel)
    {
        switch (channel)
        {
            case 11: return -2.25f + spawnArea.position.x; // 1번 키
            case 12: return -0.74f + spawnArea.position.x; // 2번 키
            case 13: return 0.75f + spawnArea.position.x;  // 3번 키
            case 14: return 2.25f + spawnArea.position.x;  // 4번 키
            default: return 0f + spawnArea.position.x;     // 기본 값
        }
    }
    private ObjectPool SelectNotePool(int channel)
    {
        // 채널에 따라 노트 풀 선택
        return (channel == 11 || channel == 14) ? notePool1 : notePool2;
    }

    private GameObject SelectPrefab(int channel)
    {
        // 채널에 따라 프리팹 선택
        if (channel == 11 || channel == 14) // 1번 키, 4번 키
        {
            return notePrefab1;
        }
        else if (channel == 12 || channel == 13) // 2번 키, 3번 키
        {
            return notePrefab2;
        }
        else
            return notePrefab1; // 기본 값
    }

    void UpdateMeasureLines()
    {

    }

    public bool TryGetNoteByIndex(int index, out Note_Multi note)
    {
        return notesByIndex.TryGetValue(index, out note);
    }


    public void InsertJudgement(int noteId, string judgement, int keyIndex, float percent)
    {
        judgementDict[noteId] = new JudgementData(noteId, judgement, keyIndex, percent);
        Debug.Log($"[MultiNoteManager] 판정 등록: noteId={noteId}, {judgement}, key={keyIndex}, percent={percent}");
    }
    public void InsertScoreData(int noteId, float percent, float curHp, float totalScore, int combo, int missCount, string judgement)
    {
        //scoreDataDict[noteId] = new ScoreData(curHp, totalScore, percent, combo, missCount, judgement);
        scoreDataQueue.Enqueue(new ScoreData(curHp, totalScore, percent, combo, missCount, judgement));
    }

    public void OutJudgement(int noteId)
    {
        if (!judgementDict.TryGetValue(noteId, out JudgementData data))
        {
            Debug.LogWarning($"[MultiNoteManager] noteId={noteId}에 대한 판정 데이터가 없습니다.");
            return;
        }
        if (!notesByIndex.TryGetValue(noteId, out Note_Multi note))
        {
            Debug.LogWarning($"[MultiNoteManager] noteId={noteId}에 해당하는 노트를 찾을 수 없습니다.");
            return;
        }

        
        note.JudgmentSimulateNote(data.judgement, data.percent);

        if (scoreDataQueue.Count == 0) return;
        var score_data = scoreDataQueue.Dequeue();
        KGB_GameManager_Multi.Instance.playUI_Multi.UpdatePlayUI_Multi(score_data);
        KGB_GameManager_Multi.Instance.scoreBoardUI.UpdateScoreBoard_p2(score_data);

        judgementDict.Remove(noteId);
    }

}
